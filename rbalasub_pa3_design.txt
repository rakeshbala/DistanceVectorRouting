CSE 589 MNC PA3 Design
Rakesh Balasubramanian

The overall flow of the program looks like below:
    * Validate arguments
    * Look for topology file
    * Get server id and port 
    * Get neighbours and set cost to all nodes from topology file
    * Run main select loop
       * Handle user commands
       * Wait for update interval and send distance vectors to neighbors
       * or 
       * Send distance vectors if 'step' command received 
       * Receive distance vectors from neighbors and update the distance vectors
    

/******* Data structure for routing Table Entry *******/
typedef struct
{
    uint16_t server_id;
    int next_hop_server_id;
    uint16_t cost_ofpath;
} RoutingTableEntry;


/******* Data structures for update field packet *******/
typedef struct
{
    uint32_t upe_server_ip_addr;
    uint16_t upe_server_port;
    uint16_t upe_server_id;
    uint16_t cost;
} Up_field_entry;

typedef struct
{
    uint16_t  num_updates;
    uint16_t server_port;
    Up_field_entry *entries; //array of update field entries
} UpdateFieldPacket;


/******* Main select loop *******/
WHILE(true)
    Set ReadFD for STDIN
    Set ReadFD for listening socket
    Set timeout value
    res = SELECT(fd_max+1,Readfd,NULL,TIMEOUT);
    if res >= 0
        if  res = 0
            HANDLE_TIMEOUT();
            continue;
        end if
        for i = 1 to fd_max
            if(FD_ISSET(ii,&Readfd))
                if i=0
                    READ_FROM_STDIN();
                else 
                    READ_FROM_SOCKET();
                end if
            end if
        end for
    end if
end while

READ_FROM_SOCKET()
    CHECK_IP_ADDR_OF_DEST(); 
    DISPLAY_UPDATE_FIELD_PACKET()
    UPDATE_ROUTING_TABLE_FROM_PKT();
END

UPDATE_ROUTING_TABLE_FROM_PKT()
    BELLMAN_FORD();
END


/******* Timer implementation using select *******/
Design: 
Keep track of the time out count and other details of each neighbour in a global struct array 
Mark the neighbour for timeout-counter reset in the global array, each time a packet is received from the neighbour
When a timeout happens, increment the timeout-counter of neighbours whose reset flag is not true
If timeout-counter becomes more than three mark the cost to that server as inf.

//Data structure used
typedef struct{
	uint16_t server_id;
	bool reset;
	int count;
} Timeout;
Timeout time_arr[]; 
//Relevant parts of main select loop
while(true)
    x <- select( â€¦ ,TIMEOUT)
    if (TIMEOUT HAPPENED) //x=0
        for i : 1 to length of time_arr
        	if time_arr[i].reset != true 	//Check if marked for reset
            	time_arr[i].count++;		//Increment counter if not marked
            	if time_arr[i] >= 3
            		SET_COST_TO_INF(time_arr[i].server_id); //Set cost of server to inf if count > 3
            	end if
            end if
        end for
    else if data received
    	s_id = GET_SERVERID_FROM_DATA(); 
    	ind = GET_INDEX_OF_TIMEOUT_FROM_SID(); //Get index of the server id in timeout array
    	time_arr[ind].reset = true;
    end if
end while